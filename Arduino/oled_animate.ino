//
// oled_animate
//
// Copyright (c) 2018 BitBank Software, Inc.
// Written by Larry Bank
// project started 5/19/2018
// bitbank@pobox.com
//
// This project is to demonstrate practical animation on I2C OLED displays driven by resource-constrained
// MCUs like the ATtiny85. By using efficient I2C bit-banging along with a simple compressed image format
// complex animations can be stored in a small amount of flash memory and played back at impressive frame
// rates.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//
// Packed animation data
//
const byte bAnimation[] PROGMEM = {
  0xe5,0x00,0x48,0x80,0xff,0x00,0xf9,0x00,0x40,0x0f,0xc0,0xe0,0xf0,0xfe,0xfe,0xff,
  0xfe,0xfc,0xf8,0xf0,0xf0,0xe0,0xe0,0xc0,0x80,0x80,0xff,0x00,0xea,0x00,0x58,0x04,
  0x0e,0x1e,0xc4,0x1f,0x50,0x3f,0x7f,0xcb,0xff,0x70,0xfe,0xf8,0xf0,0xc0,0x80,0x80,
  0xff,0x00,0xed,0x00,0x48,0x01,0xdf,0xff,0xc4,0xfe,0xc2,0xff,0xc3,0x7f,0xce,0xff,
  0x40,0x07,0x7f,0x7f,0x3f,0x3f,0x1f,0x0f,0x07,0x03,0xfd,0x00,0x50,0x03,0x07,0xcd,
  0xff,0xc6,0x7f,0xcf,0xff,0x50,0xfc,0xe0,0xc5,0x00,0xc7,0x01,0xff,0x00,0xc8,0x00,
  0x48,0xe0,0xc2,0xff,0x40,0x08,0x7f,0x1f,0x0f,0x03,0x00,0x00,0x01,0x0f,0x7f,0xc2,
  0xff,0xc6,0x00,0x50,0x07,0x3f,0xc3,0xff,0x40,0x10,0x1f,0x07,0x03,0x03,0x07,0x0f,
  0x0f,0x1f,0x1f,0x3f,0x3f,0x7f,0x7f,0xfc,0xf8,0xf0,0xe0,0xff,0x00,0xcc,0x00,0x40,
  0x08,0x80,0x80,0xc0,0xf8,0xfe,0x7f,0x1f,0x07,0x01,0xc6,0x00,0xc1,0x80,0xc2,0xff,
  0xc4,0x00,0x40,0x07,0x80,0x80,0xc0,0xf0,0xff,0xff,0x3f,0x0f,0xcc,0x00,0x68,0x01,
  0x8f,0xff,0xff,0xf0,0xff,0x00,0xca,0x00,0x68,0x01,0x01,0x03,0x03,0x01,0xcb,0x00,
  0xc3,0x01,0xc5,0x00,0xc4,0x01,0xcf,0x00,0xc3,0x03,0x48,0x01,0xe8,0x00,0x00,0x25,
  0x48,0x00,0x00,0x79,0x4a,0x80,0x51,0xf8,0xff,0x4f,0xff,0x48,0xc0,0x00,0x6b,0x48,
  0x00,0x00,0x14,0x49,0xfc,0x48,0xe0,0x00,0x70,0x48,0x00,0x00,0x1e,0x4d,0xfe,0x5a,
  0xfe,0xfe,0xbe,0x95,0xff,0xc1,0xfe,0x00,0x07,0x40,0x08,0xff,0xff,0x7f,0x7f,0x3f,
  0x1f,0x0f,0x06,0x02,0x00,0x3c,0x49,0x01,0x48,0xcf,0x00,0x0b,0x48,0x7f,0x00,0x1c,
  0xc1,0x01,0x00,0x07,0x48,0x01,0x00,0x47,0x52,0x00,0xf0,0x54,0xff,0x3f,0x59,0x7f,
  0xff,0xff,0x57,0x03,0x00,0x5b,0x00,0x0f,0x7f,0x5b,0xff,0x0f,0x07,0x49,0x1f,0x4b,
  0x3f,0x68,0xfe,0xf8,0xe0,0xe0,0x00,0x00,0x4c,0x49,0x00,0x61,0x80,0xe0,0xf8,0xff,
  0x57,0x0f,0x03,0x51,0x1f,0xff,0x55,0xf8,0x00,0x40,0x09,0x00,0x00,0x80,0x80,0xe0,
  0xfd,0x7f,0x3f,0x0f,0x02,0x00,0x0a,0x52,0x03,0xff,0x48,0x00,0x00,0x4a,0x51,0x00,
  0x03,0x49,0x01,0x48,0x01,0x00,0x0d,0x4e,0x00,0x4c,0x00,0x48,0x01,0x00,0x0e,0x68,
  0x00,0x01,0x01,0x00,0x00,0x00,0x28,0x00,0xa1,0x4d,0xf0,0x49,0xfe,0x49,0xf8,0x49,
  0xf0,0x48,0xe0,0x00,0x6d,0x5c,0x06,0x0e,0x0f,0x58,0x1f,0x1f,0x3f,0x00,0x09,0x4a,
  0xfe,0x4a,0xf0,0x48,0x00,0x00,0x6e,0x48,0x1f,0x00,0x1c,0x4c,0xfe,0x4b,0xfc,0xc2,
  0x7e,0xc6,0xfe,0x10,0xc2,0xfe,0x20,0xc2,0xfe,0x70,0x7e,0x7e,0x3e,0x3e,0x1e,0x0e,
  0x00,0x3e,0x50,0x03,0x87,0x00,0x12,0x50,0x3f,0x7f,0x00,0x0e,0x53,0xf8,0x00,0x48,
  0x01,0x00,0x0a,0xc1,0x01,0x00,0x46,0x4b,0xe0,0x49,0x7f,0x49,0x01,0x91,0xff,0x58,
  0x3f,0x07,0x00,0x00,0x08,0x5b,0x03,0x1f,0x7f,0x79,0xff,0x0f,0x0f,0x1f,0x1f,0x3f,
  0x3f,0x78,0x7f,0x7f,0xfc,0xf0,0xe0,0x00,0x00,0x00,0x4e,0x49,0x00,0x7c,0x80,0xe0,
  0xfc,0xff,0x3f,0x0f,0x01,0x70,0x0f,0x3f,0xff,0xf0,0xe0,0x00,0x00,0x07,0x40,0x07,
  0x00,0x00,0x80,0xe0,0xff,0x7f,0x1f,0x07,0x00,0x09,0x68,0xff,0xff,0x7f,0x00,0x00,
  0x00,0x4c,0x53,0x00,0x01,0x48,0x01,0x00,0x09,0x48,0x00,0x00,0x09,0x70,0x00,0x03,
  0x03,0x03,0x03,0x01,0x00,0x0d,0x58,0x01,0x00,0x00,0x00,0x2a,0x00,0x26,0x48,0x80,
  0x00,0x79,0x4a,0xe0,0x4b,0xfc,0x49,0xfc,0x49,0xf8,0x49,0xf0,0x50,0xe0,0xc0,0x00,
  0x6b,0x4a,0x02,0x78,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x1f,0x00,0x09,0x70,0xff,0xfe,
  0xfc,0xf8,0xe0,0xc0,0x00,0x6f,0x48,0x0f,0x00,0x13,0xac,0xfe,0x4c,0xff,0x4b,0xfe,
  0x48,0x3e,0x00,0x0d,0xa3,0xfe,0x49,0xfe,0x4a,0x7e,0x50,0x1e,0x0c,0x00,0x3c,0x49,
  0x00,0x48,0x07,0x00,0x0a,0x4f,0x7f,0x48,0x7f,0x00,0x0e,0x93,0x00,0x4a,0x01,0xca,
  0x03,0x09,0x01,0x00,0x45,0x52,0x00,0xf8,0x62,0xff,0x1f,0x03,0xe1,0x58,0x7f,0x1f,
  0x03,0x00,0x0b,0x48,0x3f,0x00,0x07,0x4a,0x1f,0x68,0x7e,0xf8,0xf0,0xe0,0x00,0x00,
  0x53,0x73,0x80,0xe0,0xfe,0x7f,0x1f,0x07,0x70,0x1f,0xff,0xff,0xf0,0x00,0x00,0x00,
  0x0a,0x7f,0x00,0x80,0xc0,0xff,0xff,0x3f,0x06,0x51,0x7f,0xff,0xc1,0x00,0x00,0x4f,
  0x4c,0x00,0x48,0x01,0x00,0x07,0x60,0x01,0x01,0x00,0x00,0x00,0x08,0x52,0x00,0x01,
  0x58,0x03,0x03,0x01,0x00,0x0b,0x48,0x00,0x00,0x2c,0x00,0x25,0x50,0x80,0xc0,0x00,
  0x79,0x4d,0xf0,0x55,0xff,0xfe,0x49,0xc0,0x48,0x80,0x00,0x6b,0x4f,0x06,0x48,0x3f,
  0x00,0x0e,0x48,0x80,0x00,0x6f,0x48,0x01,0x00,0x12,0x4a,0xfe,0xc2,0xff,0x00,0x08,
  0x4b,0xfc,0x49,0x7e,0x4a,0xfe,0xd3,0xfc,0x58,0x7c,0x3c,0x1c,0x00,0x53,0x50,0x3f,
  0xff,0x00,0x11,0x49,0x01,0x91,0x03,0xc8,0x07,0x0c,0x03,0x03,0x01,0x01,0x00,0x44,
  0x4b,0xf0,0xc2,0xff,0x68,0x7f,0x1f,0x07,0x01,0x00,0x00,0x09,0x4e,0x07,0x40,0x0a,
  0xff,0x3f,0x3f,0x7f,0x7f,0xff,0xff,0xf0,0x60,0x00,0x00,0x00,0x52,0x4a,0x00,0x70,
  0xc0,0xf8,0xff,0xff,0x1f,0x1f,0xc2,0xff,0x58,0xc0,0x00,0x00,0x00,0x0d,0x59,0x00,
  0x80,0xc3,0x5b,0xff,0x7f,0x06,0x70,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x52,0x74,
  0x00,0x03,0x03,0x03,0x03,0x01,0x68,0x01,0x01,0x01,0x00,0x00,0x00,0x0b,0x53,0x00,
  0x02,0x96,0x03,0xc1,0x01,0x00,0x30,0x00,0x27,0x48,0x80,0x00,0x76,0x53,0x80,0xc0,
  0x4c,0xff,0x49,0xfc,0x4a,0xf8,0x48,0xe0,0x00,0x6c,0x5c,0x00,0x07,0x07,0x49,0x07,
  0x50,0x1f,0x3f,0x00,0x09,0x68,0xff,0xfe,0xfc,0xf0,0xc0,0x00,0x6f,0x50,0x00,0x7f,
  0x00,0x10,0x4b,0xfe,0x4f,0xfe,0x92,0xff,0x54,0xfe,0xfc,0x4a,0x7e,0xc3,0xfe,0x00,
  0x51,0x5f,0x01,0x03,0x07,0x9f,0x7f,0x49,0x3f,0x48,0x3f,0x00,0x0b,0x54,0x3f,0x07,
  0x49,0x00,0x91,0x01,0x9c,0x03,0xc1,0x03,0x00,0x48,0x49,0x80,0x4a,0xfe,0x78,0x7f,
  0x0f,0x07,0x03,0x01,0x00,0x00,0x00,0x0a,0x64,0x01,0x07,0x1f,0x7f,0xc3,0xff,0x48,
  0xe0,0xc2,0x00,0x00,0x55,0x49,0x00,0x52,0x80,0xe7,0x70,0xff,0xc7,0x00,0x00,0x00,
  0x00,0x00,0x10,0x59,0x00,0x81,0xc7,0xc2,0xff,0x68,0x1f,0x07,0x01,0x00,0x00,0x00,
  0x56,0x4a,0x01,0x4d,0x01,0xc2,0x00,0x00,0x0e,0x76,0x00,0x00,0x01,0x01,0x01,0x01,
  0xc1,0x00,0x00,0x30,0x00,0x27,0x48,0x00,0x00,0x79,0x4e,0xf8,0x4c,0xf8,0x48,0xc0,
  0x00,0x6c,0x4a,0x02,0x49,0x07,0x91,0x07,0x50,0x07,0x0f,0x00,0x0c,0x4a,0xf8,0x48,
  0x80,0x00,0x86,0xc1,0xfe,0x00,0x0b,0x57,0x7e,0x3e,0x48,0xfc,0x00,0x12,0x48,0x00,
  0x00,0x3f,0x4e,0xef,0x97,0x3f,0x93,0x3f,0x48,0x3f,0x00,0x0a,0x55,0x1f,0x00,0x4a,
  0x00,0x4b,0x01,0xa3,0x03,0xc1,0x01,0x00,0x44,0x62,0xf0,0xfc,0xff,0xff,0x68,0xff,
  0xff,0x1f,0x01,0x00,0x00,0x0c,0x7c,0x00,0x00,0x03,0x07,0x0f,0x1f,0x7f,0x50,0x80,
  0x00,0x00,0x59,0x5a,0x00,0x87,0xbf,0x58,0x7f,0x1f,0x07,0x00,0x14,0x5c,0x00,0xf0,
  0xfc,0xc1,0x00,0x00,0x58,0x5a,0x00,0x01,0x01,0x48,0x01,0x00,0x16,0x92,0x00,0xc1,
  0x01,0x00,0x36,0x00,0x24,0x49,0x80,0x48,0x80,0x00,0x7f,0x59,0xfe,0xfc,0xfc,0x49,
  0xf0,0x68,0xf0,0xe0,0xe0,0xc0,0x80,0x00,0x6c,0x49,0x0f,0x70,0x0f,0x0f,0x0f,0x0f,
  0x1f,0x7f,0x00,0x0a,0x50,0xff,0xfe,0x00,0x84,0xbe,0xff,0x4a,0xfe,0x49,0xfc,0x53,
  0xfc,0x3c,0x93,0x7e,0xce,0xfe,0x5a,0x7e,0x7e,0x3c,0x48,0x08,0x00,0x3d,0x58,0x81,
  0xc7,0xf7,0x00,0x0e,0x48,0x7f,0x00,0x0f,0x4f,0x7f,0xc2,0x00,0xc9,0x01,0x10,0xc1,
  0x00,0x00,0x40,0x7b,0xe0,0xf8,0x7e,0x3f,0x1f,0x07,0x87,0x50,0x7f,0x03,0x00,0x12,
  0x54,0x9f,0xff,0x48,0xff,0x00,0x59,0x40,0x09,0x3f,0x7f,0x00,0x00,0x80,0xe0,0xff,
  0xff,0x3f,0x0f,0x00,0x11,0x40,0x09,0x78,0x3c,0x1e,0x0f,0x87,0x81,0xc0,0xf9,0xff,
  0x0f,0x00,0x5a,0x93,0x00,0x48,0x01,0x00,0x17,0x4b,0x00,0x48,0x01,0x00,0x35,0x00,
  0x24,0x49,0x00,0x48,0x00,0x00,0x81,0x49,0xf8,0x49,0xf8,0x49,0xe0,0x58,0xc0,0x80,
  0x00,0x00,0x6b,0x4d,0x0f,0x58,0x1f,0x3f,0xff,0x00,0x0a,0x50,0xfc,0xf8,0x00,0x71,
  0x50,0x07,0xff,0x00,0x0f,0xc3,0xfe,0x00,0x07,0xc1,0xfe,0x00,0x0a,0x48,0xfe,0x00,
  0x10,0x49,0x7e,0x49,0x3e,0x58,0x1c,0x0c,0x00,0x00,0x3c,0x66,0x80,0xc3,0xf3,0xff,
  0x50,0xff,0x7f,0x00,0x17,0x50,0xff,0x08,0x00,0x08,0x4e,0x00,0xc4,0x00,0x00,0x40,
  0x79,0xc0,0xf0,0xfc,0x3f,0x3f,0x1f,0x0f,0x4b,0x07,0x58,0xff,0x3f,0x01,0x00,0x0e,
  0x61,0x07,0x8f,0xff,0xff,0x61,0x7f,0x3f,0x7f,0x7f,0x58,0xff,0xf0,0xc0,0x00,0x52,
  0x73,0x70,0x7e,0x7f,0x1f,0x01,0x00,0x51,0x80,0xc0,0x58,0xff,0x3f,0x07,0x00,0x0d,
  0x78,0x70,0x7c,0x3e,0x1f,0x0f,0x07,0x03,0xc2,0x00,0x70,0x80,0x80,0xff,0xff,0x7f,
  0x0f,0x00,0x59,0x52,0x00,0x03,0x48,0x01,0x00,0x17,0x78,0x00,0x00,0x00,0x03,0x01,
  0x01,0x01,0x00,0x32,0x00,0xa0,0x5d,0x80,0xe0,0xf0,0x4a,0xf8,0x4a,0xf0,0x58,0xc0,
  0x80,0x00,0x00,0x6a,0x55,0x06,0x0e,0x58,0x1f,0x3f,0x7f,0x00,0x0a,0x4a,0xfe,0x48,
  0xe0,0x00,0x70,0x48,0x1f,0x00,0x10,0xa7,0xff,0x4e,0xfe,0xc2,0xfe,0x00,0x18,0x58,
  0x1e,0x0e,0x04,0x00,0x3d,0x58,0x00,0x03,0xc7,0x00,0x07,0x48,0xff,0x00,0x07,0x4b,
  0x7f,0x48,0xff,0x00,0x0b,0x5d,0xff,0xfe,0xe0,0x9e,0x01,0xc1,0x01,0x00,0x43,0x40,
  0x0b,0x00,0x80,0xf0,0xf8,0xfe,0x7f,0x3f,0x1f,0x0f,0x07,0x03,0x7f,0x08,0xc2,0xff,
  0x00,0x0c,0x5b,0x07,0x1f,0xff,0x40,0x0b,0x07,0x0f,0x1f,0x3f,0x3f,0x7f,0x7f,0xff,
  0xff,0xf0,0xc0,0xc0,0x00,0x4e,0x72,0x80,0xe0,0xfc,0xff,0x3f,0x07,0xc2,0x00,0x78,
  0x80,0x80,0xe0,0xff,0xff,0x3f,0x0f,0x00,0x09,0x79,0xc0,0xe0,0xf0,0x7c,0x3f,0x1f,
  0x0f,0x4a,0x01,0xc3,0x00,0x70,0x80,0x80,0xc1,0xff,0xff,0x1f,0x00,0x56,0x99,0x00,
  0xc3,0x01,0x00,0x16,0xc3,0x00,0xc4,0x01,0x00,0x2d,0x00,0x9f,0x57,0x00,0xc0,0x68,
  0xfc,0xf0,0xf0,0xe0,0xe0,0x00,0x6d,0x58,0x04,0x0e,0x1e,0xc4,0x1f,0x11,0xff,0x00,
  0x0c,0x48,0xf0,0x00,0x70,0x50,0x01,0x7f,0x00,0x1b,0x94,0xff,0x4a,0xfe,0x60,0xff,
  0xff,0x7f,0x7f,0xc7,0xff,0x18,0xc7,0xff,0x60,0x7f,0x7f,0x3f,0x1f,0x0a,0x06,0x02,
  0x00,0x3c,0x60,0x01,0x07,0x87,0xef,0x00,0x07,0xb3,0xff,0x58,0x7f,0x7f,0xff,0x00,
  0x0d,0x5b,0xff,0xfc,0x80,0x48,0x01,0x00,0x0a,0x48,0x01,0x00,0x43,0x40,0x0d,0x00,
  0x00,0xe0,0xf8,0xfe,0xff,0x7f,0x1f,0x0f,0x07,0x03,0x01,0x00,0x0f,0x08,0xc2,0xff,
  0x00,0x07,0x62,0x07,0x3f,0x7f,0xff,0x52,0x9f,0x07,0x40,0x0b,0x0f,0x1f,0x1f,0x3f,
  0x3f,0x7f,0x7f,0xff,0xfc,0xf0,0xe0,0xe0,0x00,0x4d,0x7b,0xc0,0xe0,0xf8,0xff,0x7f,
  0x1f,0x07,0xc4,0x00,0xc1,0x80,0xc2,0xff,0x4d,0x0e,0x6c,0xc0,0xe0,0xf0,0xf8,0x7e,
  0x4e,0x00,0xc3,0x00,0x48,0x83,0xc2,0xff,0x00,0x4c,0xa7,0x01,0xa1,0x00,0x60,0x01,
  0x03,0x03,0x01,0x00,0x16,0x99,0x00,0x60,0x03,0x03,0x03,0x01,0x00,0x2a
};

//
// Byte operands for compressing the data
// The first 2 bits are the type, followed by the counts
#define OP_MASK 0xc0
#define OP_SKIPCOPY 0x00
#define OP_COPYSKIP 0x40
#define OP_REPEATSKIP 0x80
#define OP_REPEAT 0xc0

// Some globals
static int iScreenOffset; // current write offset of screen data
static int iFrameDelay; // milliseconds to pause between frames
static byte oled_addr; // I2C address of the display
static void oledWriteCommand(unsigned char c);
// Hardware ports of the AVR
#define I2CPORT PORTB
// A bit set to 1 in the DDR is an output, 0 is an INPUT
#define I2CDDR DDRB

// Pin or port numbers for SDA and SCL
#define BB_SDA 0
#define BB_SCL 2
#define DELAY 1
#ifndef DELAY_CYCLES
#define DELAY_CYCLES(n) __builtin_avr_delay_cycles(n)
#endif

//
// If the display doesn't properly implement the horizontal addressing mode, it requires
// additional effort to transmit the images
//
#define BAD_DISPLAY
//
// Transmit a byte and ack bit
//
static inline void i2cByteOut(byte b)
{
byte i;
byte bOld = I2CPORT & ~((1 << BB_SDA) | (1 << BB_SCL));

     for (i=0; i<8; i++)
     {
         bOld &= ~(1 << BB_SDA);
         if (b & 0x80)
            bOld |= (1 << BB_SDA);
         I2CPORT = bOld;
         DELAY_CYCLES(DELAY);
         I2CPORT |= (1 << BB_SCL);
         DELAY_CYCLES(DELAY);
         I2CPORT = bOld;
         b <<= 1;
     } // for i
// ack bit
  I2CPORT = bOld & ~(1 << BB_SDA); // set data low
  DELAY_CYCLES(DELAY);
  I2CPORT |= (1 << BB_SCL); // toggle clock
  DELAY_CYCLES(DELAY);
  I2CPORT = bOld;
} /* i2cByteOut() */

void i2cBegin(byte addr)
{
   I2CPORT |= ((1 << BB_SDA) + (1 << BB_SCL));
   I2CDDR |= ((1 << BB_SDA) + (1 << BB_SCL));
   I2CPORT &= ~(1 << BB_SDA); // data line low first
   DELAY_CYCLES(DELAY);
   I2CPORT &= ~(1 << BB_SCL); // then clock line low is a START signal
   i2cByteOut(addr << 1); // send the slave address
} /* i2cBegin() */

void i2cWrite(byte *pData, byte bLen)
{
byte b;

   while (bLen--)
   {
      b = *pData++;
      i2cByteOut(b);
   } // for each byte
} /* i2cWrite() */

//
// Send I2C STOP condition
//
void i2cEnd()
{
  I2CPORT &= ~(1 << BB_SDA);
  I2CPORT |= (1 << BB_SCL);
  I2CPORT |= (1 << BB_SDA);
  I2CDDR &= ((1 << BB_SDA) | (1 << BB_SCL)); // let the lines float (tri-state)
} /* i2cEnd() */

// Wrapper function to write I2C data on Arduino
static void I2CWrite(int iAddr, unsigned char *pData, int iLen)
{
  i2cBegin(iAddr);
  i2cWrite(pData, iLen);
  i2cEnd();
} /* I2CWrite() */
//
// Write a block of flash memory to the display
//
void oledWriteFlashBlock(byte *s, int iLen)
{
int i;
byte b;

#ifdef BAD_DISPLAY
  {
  int j;
     while (((iScreenOffset & 0x7f) + iLen) >= 128) // if it will hit the page end
     {
        j = 128 - (iScreenOffset & 0x7f); // amount we can write in one shot
        i2cBegin(oled_addr);
        i2cByteOut(0x40); // start of data
        for (i=0; i<j; i++)
           {
              b = pgm_read_byte(s++);
              i2cByteOut(b);
           }
        i2cEnd(); 
        iLen -= j;
        iScreenOffset = (iScreenOffset + j) & 0x3ff;
        oledSetPosition(iScreenOffset & 0x7f, (iScreenOffset >> 7));
     } // while it needs some help
  }
#endif // simpler case and leftover bytes
  i2cBegin(oled_addr);
  i2cByteOut(0x40); // start of data
  for (i=0; i<iLen; i++)
  {
    b = pgm_read_byte(s++);
    i2cByteOut(b);
  }
  i2cEnd();
  iScreenOffset = (iScreenOffset + iLen) & 0x3ff;
} /* oledWriteFlashBlock() */

//
// Write a repeating byte to the display
//
void oledRepeatByte(byte b, int iLen)
{
int i;

#ifdef BAD_DISPLAY
  {
  int j;
     while (((iScreenOffset & 0x7f) + iLen) >= 128) // if it will hit the page end
     {
        j = 128 - (iScreenOffset & 0x7f); // amount we can write in one shot
        i2cBegin(oled_addr);
        i2cByteOut(0x40); // start of data
        for (i=0; i<j; i++)
           {
              i2cByteOut(b);
           }
        i2cEnd(); 
        iLen -= j;
        iScreenOffset = (iScreenOffset + j) & 0x3ff;
        oledSetPosition(iScreenOffset & 0x7f, (iScreenOffset >> 7));
     } // while it needs some help
  }
#endif // simpler case and leftover bytes
  i2cBegin(oled_addr);
  i2cByteOut(0x40); // start of data
  for (i=0; i<iLen; i++)
  {
    i2cByteOut(b);
  }
  i2cEnd();  
  iScreenOffset += iLen;
} /* oledRepeatByte() */

//
// Initializes the OLED controller into "page mode"
//
void oledInit(byte bAddr, int bFlip, int bInvert)
{
unsigned char uc[4];
unsigned char oled_initbuf[]={0x00,0xae,0xa8,0x3f,0xd3,0x00,0x40,0xa1,0xc8,
      0xda,0x12,0x81,0xff,0xa4,0xa6,0xd5,0x80,0x8d,0x14,
      0xaf,0x20,0x00};

  oled_addr = bAddr;
  I2CDDR &= ~(1 << BB_SDA);
  I2CDDR &= ~(1 << BB_SCL); // let them float high
  I2CPORT |= (1 << BB_SDA); // set both lines to get pulled up
  I2CPORT |= (1 << BB_SCL);
  
  I2CWrite(oled_addr, oled_initbuf, sizeof(oled_initbuf));
  if (bInvert)
  {
    uc[0] = 0; // command
    uc[1] = 0xa7; // invert command
    I2CWrite(oled_addr, uc, 2);
  }
  if (bFlip) // rotate display 180
  {
    uc[0] = 0; // command
    uc[1] = 0xa0;
    I2CWrite(oled_addr, uc, 2);
    uc[1] = 0xc0;
    I2CWrite(oled_addr, uc, 2);
  }
} /* oledInit() */
//
// Sends a command to turn off the OLED display
//
void oledShutdown()
{
    oledWriteCommand(0xaE); // turn off OLED
}

// Send a single byte command to the OLED controller
static void oledWriteCommand(unsigned char c)
{
unsigned char buf[2];

  buf[0] = 0x00; // command introducer
  buf[1] = c;
  I2CWrite(oled_addr, buf, 2);
} /* oledWriteCommand() */

static void oledWriteCommand2(unsigned char c, unsigned char d)
{
unsigned char buf[3];

  buf[0] = 0x00;
  buf[1] = c;
  buf[2] = d;
  I2CWrite(oled_addr, buf, 3);
} /* oledWriteCommand2() */

//
// Sets the brightness (0=off, 255=brightest)
//
void oledSetContrast(unsigned char ucContrast)
{
  oledWriteCommand2(0x81, ucContrast);
} /* oledSetContrast() */

//
// Send commands to position the "cursor" (aka memory write address)
// to the given row and column
//
static void oledSetPosition(int x, int y)
{
  oledWriteCommand(0xb0 | y); // go to page Y
  oledWriteCommand(0x00 | (x & 0xf)); // // lower col addr
  oledWriteCommand(0x10 | ((x >> 4) & 0xf)); // upper col addr
  iScreenOffset = (y*128)+x;
}

void oledPlayAnim(int iRate, int iLoop)
{
byte *s;
byte *pEnd;
int j, l, i;
unsigned char b, bCode;

   iFrameDelay = (1000UL / (long)iRate);
   for (l=0; l<iLoop; l++)
   {
      s = (byte *)bAnimation; // start of animation data
      pEnd = &s[sizeof(bAnimation)];
      while (s < pEnd)
      {
      i = 0;
         oledSetPosition(0,0);
         while (i < 1024) // try one frame
         {
            bCode = pgm_read_byte(s++);
            switch (bCode & OP_MASK) // different compression types
            {
               case OP_SKIPCOPY: // skip/copy
                  if (bCode == OP_SKIPCOPY) // big skip
                  {
                     b = pgm_read_byte(s++);
                     i += b + 1;
                     oledSetPosition(i & 0x7f, (i >> 7));
                  }
                  else // skip/copy
                  {
                     if (bCode & 0x38)
                     {
                        i += ((bCode & 0x38) >> 3); // skip amount
                        oledSetPosition(i & 0x7f, (i >> 7));
                     }
                     if (bCode & 7)
                     {
                        oledWriteFlashBlock(s, bCode & 7);
                        s += (bCode & 7);
                        i += bCode & 7;
                     }
                  }
               break;
            case OP_COPYSKIP: // copy/skip
               if (bCode == OP_COPYSKIP) // big copy
               {
                  b = pgm_read_byte(s++);
                  j = b + 1;
                  oledWriteFlashBlock(s, j);
                  s += j;
                  i += j;
               }
               else
               {
                  j = ((bCode & 0x38) >> 3);
                  if (j)
                  {
                     oledWriteFlashBlock(s, j);
                     s += j;
                     i += j;
                  }
                  if (bCode & 7)
                  {
                     i += (bCode & 7); // skip
                  oledSetPosition(i & 0x7f, (i >> 7));
               }
            }
            break;
               case OP_REPEATSKIP: // repeat/skip
                  j = (bCode & 0x38) >> 3; // repeat count
                  b = pgm_read_byte(s++);
                  oledRepeatByte(b, j);
                  i += j;
                  if (bCode & 7)
                  {
                     i += (bCode & 7); // skip amount
                     oledSetPosition(i & 0x7f, (i >> 7));
                  }
                  break;
                  
               case OP_REPEAT:
                  j = (bCode & 0x3f) + 1;
                  b = pgm_read_byte(s++);
                  oledRepeatByte(b, j);
                  i += j;
                  break;  
         } // switch on code type
      } // while rendering frame
   delay(iFrameDelay);
   } // while playing frames
   } // for loop count
} /* PlayAnim() */

//
// Fill the frame buffer with a byte pattern
// e.g. all off (0x00) or all on (0xff)
//
void oledFill(unsigned char ucData)
{
int y;

  for (y=0; y<8; y++)
  {
    oledSetPosition(0,y); // set to (0,Y)
    oledRepeatByte(ucData, 128); 
  } // for y
} /* oledFill() */

void setup() {
  // put your setup code here, to run once:
  delay(50); // wait for the OLED to fully power up
  oledInit(0x3c, 0, 0);
  oledFill(0);
}

void loop() {
  // put your main code here, to run repeatedly:
   oledPlayAnim(30, 5); // play 5 loops at 20FPS
}
